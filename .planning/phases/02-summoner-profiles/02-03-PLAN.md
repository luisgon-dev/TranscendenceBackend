---
phase: 02-summoner-profiles
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - Transcendence.Service.Core/Services/Analysis/Interfaces/ISummonerStatsService.cs
  - Transcendence.Service.Core/Services/Analysis/Implementations/SummonerStatsService.cs
  - Transcendence.Service.Core/Services/Caching/CacheService.cs
autonomous: true

must_haves:
  truths:
    - "Profile stats queries use HybridCache for sub-500ms responses"
    - "Cache keys include summonerId to prevent cross-user pollution"
    - "Cache TTL appropriate for stats data (5 minutes for stats)"
  artifacts:
    - path: "Transcendence.Service.Core/Services/Analysis/Implementations/SummonerStatsService.cs"
      provides: "Cached stats queries"
      contains: "_cache"
  key_links:
    - from: "SummonerStatsService"
      to: "HybridCache"
      via: "GetOrCreateAsync for stats queries"
      pattern: "GetOrCreateAsync"
---

<objective>
Add caching to stats queries to meet sub-500ms performance requirement.

Purpose: Success criteria requires "complete profile in <500ms". Stats queries hit the database with aggregations that may be slow on large datasets. Phase 1 established HybridCache infrastructure - this plan applies it to stats endpoints.

Output: SummonerStatsService methods use HybridCache with appropriate TTLs for stats data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/02-summoner-profiles/02-01-PLAN.md
@.planning/phases/02-summoner-profiles/02-02-PLAN.md

@Transcendence.Service.Core/Services/Caching/CacheService.cs
@Transcendence.Service.Core/Services/Analysis/Implementations/SummonerStatsService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add HybridCache to SummonerStatsService</name>
  <files>Transcendence.Service.Core/Services/Analysis/Implementations/SummonerStatsService.cs</files>
  <action>
Inject HybridCache into SummonerStatsService:

1. Add constructor parameter:
```csharp
public class SummonerStatsService(
    TranscendenceContext db,
    HybridCache cache) : ISummonerStatsService
```

2. Define cache key constants at class level:
```csharp
private const string OverviewCacheKeyPrefix = "stats:overview:";
private const string ChampionsCacheKeyPrefix = "stats:champions:";
private const string RolesCacheKeyPrefix = "stats:roles:";
private const string RecentMatchesCacheKeyPrefix = "stats:recent:";
```

3. Define cache options:
```csharp
private static readonly HybridCacheEntryOptions StatsCacheOptions = new()
{
    Expiration = TimeSpan.FromMinutes(5),
    LocalCacheExpiration = TimeSpan.FromMinutes(2)
};
```

Stats TTL rationale:
- 5 minutes total: Stats change when new matches are added (after refresh)
- 2 minutes L1: Quick invalidation if user triggers refresh
- Shorter than profile/rank (Phase 1 used 5min L1, 1hr L2) because stats are aggregated from matches
  </action>
  <verify>dotnet build Transcendence.Service.Core</verify>
  <done>HybridCache injected into SummonerStatsService with cache key constants and options</done>
</task>

<task type="auto">
  <name>Task 2: Wrap stats methods with cache</name>
  <files>Transcendence.Service.Core/Services/Analysis/Implementations/SummonerStatsService.cs</files>
  <action>
Wrap each stats method with HybridCache.GetOrCreateAsync:

**GetSummonerOverviewAsync:**
```csharp
public async Task<SummonerOverviewStats> GetSummonerOverviewAsync(
    Guid summonerId, int recentGamesCount, CancellationToken ct)
{
    var cacheKey = $"{OverviewCacheKeyPrefix}{summonerId}:{recentGamesCount}";
    return await cache.GetOrCreateAsync(
        cacheKey,
        async cancel => await ComputeOverviewAsync(summonerId, recentGamesCount, cancel),
        StatsCacheOptions,
        cancellationToken: ct);
}

private async Task<SummonerOverviewStats> ComputeOverviewAsync(
    Guid summonerId, int recentGamesCount, CancellationToken ct)
{
    // Move existing implementation here
}
```

**GetChampionStatsAsync:**
```csharp
var cacheKey = $"{ChampionsCacheKeyPrefix}{summonerId}:{top}";
// Same pattern - extract to ComputeChampionStatsAsync
```

**GetRoleBreakdownAsync:**
```csharp
var cacheKey = $"{RolesCacheKeyPrefix}{summonerId}";
// Same pattern - extract to ComputeRoleBreakdownAsync
```

**GetRecentMatchesAsync:**
```csharp
var cacheKey = $"{RecentMatchesCacheKeyPrefix}{summonerId}:{page}:{pageSize}";
// Same pattern - extract to ComputeRecentMatchesAsync
```

**GetMatchDetailAsync (from Plan 02-01):**
Match details are immutable once stored - use longer cache:
```csharp
private static readonly HybridCacheEntryOptions MatchDetailCacheOptions = new()
{
    Expiration = TimeSpan.FromHours(1),
    LocalCacheExpiration = TimeSpan.FromMinutes(15)
};

var cacheKey = $"match:detail:{matchId}";
```

Note: HybridCache handles stampede protection automatically - only one caller executes the factory for a given key.
  </action>
  <verify>dotnet build Transcendence.Service.Core</verify>
  <done>All stats methods wrapped with HybridCache, using appropriate TTLs per data type</done>
</task>

<task type="auto">
  <name>Task 3: Add cache invalidation on summoner refresh</name>
  <files>Transcendence.Service.Core/Services/Jobs/SummonerRefreshJob.cs</files>
  <action>
When a summoner is refreshed, their stats cache should be invalidated:

1. Inject HybridCache into SummonerRefreshJob (if not already present)

2. After successfully saving new match data, invalidate stats cache:
```csharp
// After matches saved, invalidate stats cache for this summoner
await InvalidateStatsCacheAsync(summoner.Id, ct);

private async Task InvalidateStatsCacheAsync(Guid summonerId, CancellationToken ct)
{
    // HybridCache doesn't have wildcard invalidation, but we can remove known keys
    // The cache will naturally expire, but we can force invalidation for common patterns

    // Common recentGamesCount values
    foreach (var count in new[] { 10, 20, 50 })
    {
        await cache.RemoveAsync($"stats:overview:{summonerId}:{count}", ct);
    }

    // Common top champion counts
    foreach (var top in new[] { 5, 10 })
    {
        await cache.RemoveAsync($"stats:champions:{summonerId}:{top}", ct);
    }

    // Roles has no parameters
    await cache.RemoveAsync($"stats:roles:{summonerId}", ct);

    // Invalidate first few pages of recent matches
    foreach (var page in new[] { 1, 2, 3 })
    {
        await cache.RemoveAsync($"stats:recent:{summonerId}:{page}:20", ct);
        await cache.RemoveAsync($"stats:recent:{summonerId}:{page}:10", ct);
    }
}
```

This ensures that after a refresh, the next profile request gets fresh stats.
  </action>
  <verify>dotnet build Transcendence.Service.Core</verify>
  <done>Stats cache invalidated when summoner data is refreshed</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `dotnet build Transcendence.sln` succeeds without errors
- [ ] HybridCache injected and used in SummonerStatsService
- [ ] All stats methods use cache with appropriate TTLs
- [ ] Cache keys include summonerId to prevent cross-user data
- [ ] Refresh job invalidates stats cache after updating data
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Repeated stats queries hit cache (sub-500ms response)
- Fresh data available after refresh completes
</success_criteria>

<output>
After completion, create `.planning/phases/02-summoner-profiles/02-03-SUMMARY.md`
</output>
