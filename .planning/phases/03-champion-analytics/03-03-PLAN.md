---
phase: 03-champion-analytics
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - Transcendence.Service.Core/Services/Analytics/Models/ChampionBuildDto.cs
  - Transcendence.Service.Core/Services/Analytics/Interfaces/IChampionAnalyticsComputeService.cs
  - Transcendence.Service.Core/Services/Analytics/Interfaces/IChampionAnalyticsService.cs
  - Transcendence.Service.Core/Services/Analytics/Implementations/ChampionAnalyticsComputeService.cs
  - Transcendence.Service.Core/Services/Analytics/Implementations/ChampionAnalyticsService.cs
  - Transcendence.WebAPI/Controllers/ChampionAnalyticsController.cs
autonomous: true

must_haves:
  truths:
    - "GET /api/analytics/champions/{championId}/builds returns top 3 builds per champion"
    - "Builds include items and runes bundled together"
    - "Core items (70%+ appearance rate) are distinguished from situational items"
    - "Boots, trinkets, and consumables are excluded from core item calculation"
  artifacts:
    - path: "Transcendence.Service.Core/Services/Analytics/Models/ChampionBuildDto.cs"
      provides: "Build DTO with items, runes, core/situational distinction"
      exports: ["ChampionBuildDto", "ChampionBuildsResponse"]
    - path: "Transcendence.WebAPI/Controllers/ChampionAnalyticsController.cs"
      provides: "Build recommendations endpoint"
      exports: ["GET /api/analytics/champions/{championId}/builds"]
  key_links:
    - from: "ChampionAnalyticsComputeService"
      to: "MatchParticipantItem + MatchParticipantRune"
      via: "EF Include for item/rune clustering"
      pattern: "Include.*Items.*Include.*Runes"
    - from: "Build grouping"
      to: "Item frequency"
      via: "70% threshold for core items"
      pattern: ">= 0.70"
---

<objective>
Implement build recommendations showing top 3 builds per champion with items and runes bundled, distinguishing core items (70%+) from situational (CHAMP-02).

Purpose: Help users understand optimal item/rune combinations for each champion, with clear indication of which items are core vs situational.

Output: Working `/api/analytics/champions/{championId}/builds` endpoint returning top 3 builds with core/situational item classification.
</objective>

<execution_context>
@C:\Users\luigon\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\luigon\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-champion-analytics/03-CONTEXT.md
@.planning/phases/03-champion-analytics/03-RESEARCH.md
@.planning/phases/03-champion-analytics/03-01-SUMMARY.md
@Transcendence.Data/Models/LoL/Match/MatchParticipantItem.cs
@Transcendence.Data/Models/LoL/Match/MatchParticipantRune.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create build recommendation DTOs</name>
  <files>
    Transcendence.Service.Core/Services/Analytics/Models/ChampionBuildDto.cs
  </files>
  <action>
    Create DTOs for build recommendations:

    ```csharp
    namespace Transcendence.Service.Core.Services.Analytics.Models;

    /// <summary>
    /// A specific item + rune build with performance stats.
    /// </summary>
    public record ChampionBuildDto(
        List<int> Items,              // Full item list for this build
        List<int> CoreItems,          // Items that appear in 70%+ of all games (not just this build)
        List<int> SituationalItems,   // Items in this build that aren't core
        int PrimaryStyleId,           // Primary rune tree (e.g., Precision)
        int SubStyleId,               // Secondary rune tree (e.g., Domination)
        List<int> PrimaryRunes,       // 4 runes from primary tree
        List<int> SubRunes,           // 2 runes from sub tree
        List<int> StatShards,         // 3 stat shards
        int Games,                    // Number of games with this exact build
        double WinRate                // Win rate for this build (0.0 to 1.0)
    );

    /// <summary>
    /// Response containing top builds for a champion.
    /// </summary>
    public record ChampionBuildsResponse(
        int ChampionId,
        string Role,
        string RankTier,
        string Patch,
        List<int> GlobalCoreItems,    // Items core across ALL builds for this champion
        List<ChampionBuildDto> Builds // Top 3 builds ordered by (games * winRate)
    );

    /// <summary>
    /// Skill order for ability maxing (requires Timeline API - placeholder for future).
    /// NOTE: Phase 3 does not fetch Timeline data. Skill order will be null until
    /// Timeline API integration is added.
    /// </summary>
    public record SkillOrderDto(
        string FirstThree,            // e.g., "QWE" or "QEW"
        string MaxOrder               // e.g., "Q>E>W"
    );
    ```

    **Note:** Skill order requires Match Timeline API which Phase 2 did not fetch. Mark as limitation per RESEARCH.md - skill order fields exist but will be null until Timeline integration.
  </action>
  <verify>File exists: `type Transcendence.Service.Core\Services\Analytics\Models\ChampionBuildDto.cs`</verify>
  <done>Build DTOs include items, runes bundled, and core/situational distinction</done>
</task>

<task type="auto">
  <name>Task 2: Implement build computation with item frequency analysis</name>
  <files>
    Transcendence.Service.Core/Services/Analytics/Interfaces/IChampionAnalyticsComputeService.cs
    Transcendence.Service.Core/Services/Analytics/Implementations/ChampionAnalyticsComputeService.cs
  </files>
  <action>
    1. **Add to IChampionAnalyticsComputeService.cs**:
       ```csharp
       Task<ChampionBuildsResponse> ComputeBuildsAsync(
           int championId,
           string role,
           string? rankTier,
           string patch,
           CancellationToken ct);
       ```

    2. **Add to ChampionAnalyticsComputeService.cs**:
       ```csharp
       // Excluded items: boots, trinkets, consumables
       private static readonly HashSet<int> ExcludedFromCore = new()
       {
           // Boots (Tier 2)
           3006, 3009, 3020, 3047, 3111, 3117, 3158,
           // Tier 1 boots
           1001,
           // Trinkets
           3340, 3363, 3364,
           // Consumables
           2003, 2031, 2033, 2055, 2138, 2139, 2140
       };

       private const double CoreItemThreshold = 0.70;
       private const int MinBuildSampleSize = 30;

       public async Task<ChampionBuildsResponse> ComputeBuildsAsync(
           int championId,
           string role,
           string? rankTier,
           string patch,
           CancellationToken ct)
       {
           // Step 1: Get all match data for this champion/role/patch/tier with items and runes
           var baseQuery = db.MatchParticipants
               .AsNoTracking()
               .Include(mp => mp.Items)
               .Include(mp => mp.Runes)
               .Where(mp => mp.ChampionId == championId
                         && mp.Match.Patch == patch
                         && mp.Match.Status == FetchStatus.Success
                         && mp.TeamPosition == role);

           // Join with Rank for tier filtering
           var query = baseQuery
               .Join(
                   db.Ranks.Where(r => r.QueueType == "RANKED_SOLO_5x5"
                       && (string.IsNullOrEmpty(rankTier) || r.Tier == rankTier)),
                   mp => mp.SummonerId,
                   r => r.SummonerId,
                   (mp, r) => mp
               );

           var matchData = await query
               .Select(mp => new
               {
                   mp.Win,
                   Items = mp.Items.Select(i => i.ItemId).ToList(),
                   Runes = mp.Runes.Select(r => r.RuneId).ToList()
               })
               .ToListAsync(ct);

           if (matchData.Count < MinimumGamesRequired)
               return new ChampionBuildsResponse(championId, role, rankTier ?? "all", patch,
                   new List<int>(), new List<ChampionBuildDto>());

           // Step 2: Calculate global core items (appear in 70%+ of ALL games, excluding boots/trinkets/consumables)
           var totalGames = matchData.Count;
           var itemFrequency = matchData
               .SelectMany(m => m.Items.Where(i => i != 0 && !ExcludedFromCore.Contains(i)))
               .GroupBy(itemId => itemId)
               .ToDictionary(
                   g => g.Key,
                   g => (double)g.Count() / totalGames
               );

           var globalCoreItems = itemFrequency
               .Where(kvp => kvp.Value >= CoreItemThreshold)
               .Select(kvp => kvp.Key)
               .ToList();

           // Step 3: Get rune metadata for style determination
           var allRuneIds = matchData.SelectMany(m => m.Runes).Distinct().ToList();
           var runeMetadata = await db.RuneVersions
               .AsNoTracking()
               .Where(rv => allRuneIds.Contains(rv.RuneId) && rv.PatchVersion == patch)
               .ToDictionaryAsync(rv => rv.RuneId, rv => new { rv.RunePathId, rv.Slot }, ct);

           // Step 4: Group by build (items + runes as key)
           var buildGroups = matchData
               .Select(m => new
               {
                   m.Win,
                   // Normalize item list (sort, exclude empty)
                   ItemKey = string.Join(",", m.Items.Where(i => i != 0).OrderBy(i => i)),
                   // Build rune structure
                   RuneInfo = BuildRuneInfo(m.Runes, runeMetadata),
                   Items = m.Items.Where(i => i != 0).OrderBy(i => i).ToList()
               })
               .GroupBy(m => new { m.ItemKey, m.RuneInfo.Key })
               .Select(g => new
               {
                   Items = g.First().Items,
                   RuneInfo = g.First().RuneInfo,
                   Games = g.Count(),
                   Wins = g.Sum(x => x.Win ? 1 : 0),
                   WinRate = (double)g.Sum(x => x.Win ? 1 : 0) / g.Count()
               })
               .Where(b => b.Games >= MinBuildSampleSize)
               .OrderByDescending(b => b.Games * b.WinRate) // Score: popularity * success
               .Take(3)
               .ToList();

           // Step 5: Map to DTOs
           var builds = buildGroups.Select(build => new ChampionBuildDto(
               build.Items,
               globalCoreItems,
               build.Items.Where(i => !globalCoreItems.Contains(i) && !ExcludedFromCore.Contains(i)).ToList(),
               build.RuneInfo.PrimaryStyleId,
               build.RuneInfo.SubStyleId,
               build.RuneInfo.PrimaryRunes,
               build.RuneInfo.SubRunes,
               build.RuneInfo.StatShards,
               build.Games,
               build.WinRate
           )).ToList();

           return new ChampionBuildsResponse(
               championId,
               role,
               rankTier ?? "all",
               patch,
               globalCoreItems,
               builds
           );
       }

       private record RuneInfoResult(
           string Key,
           int PrimaryStyleId,
           int SubStyleId,
           List<int> PrimaryRunes,
           List<int> SubRunes,
           List<int> StatShards
       );

       private static RuneInfoResult BuildRuneInfo(
           List<int> runeIds,
           Dictionary<int, (int RunePathId, int Slot)> runeMetadata)
       {
           var runesByPath = new Dictionary<int, List<(int RuneId, int Slot)>>();

           foreach (var runeId in runeIds)
           {
               if (runeMetadata.TryGetValue(runeId, out var meta))
               {
                   if (!runesByPath.ContainsKey(meta.RunePathId))
                       runesByPath[meta.RunePathId] = new List<(int, int)>();
                   runesByPath[meta.RunePathId].Add((runeId, meta.Slot));
               }
           }

           var primaryStyleId = 0;
           var subStyleId = 0;
           var primaryRunes = new List<int>();
           var subRunes = new List<int>();
           var statShards = new List<int>();

           foreach (var (pathId, runes) in runesByPath)
           {
               if (pathId >= 5000) // Stat shards
               {
                   statShards = runes.OrderBy(r => r.Slot).Select(r => r.RuneId).ToList();
               }
               else if (runes.Count >= 3) // Primary (4 runes)
               {
                   primaryStyleId = pathId;
                   primaryRunes = runes.OrderBy(r => r.Slot).Select(r => r.RuneId).ToList();
               }
               else // Sub (2 runes)
               {
                   subStyleId = pathId;
                   subRunes = runes.OrderBy(r => r.Slot).Select(r => r.RuneId).ToList();
               }
           }

           // Build unique key for grouping
           var key = $"{primaryStyleId}:{string.Join(",", primaryRunes)}|{subStyleId}:{string.Join(",", subRunes)}|{string.Join(",", statShards)}";

           return new RuneInfoResult(key, primaryStyleId, subStyleId, primaryRunes, subRunes, statShards);
       }
       ```
  </action>
  <verify>Build: `dotnet build Transcendence.Service.Core`</verify>
  <done>Build computation clusters item+rune combinations with 70% core threshold, excludes boots/trinkets/consumables</done>
</task>

<task type="auto">
  <name>Task 3: Add builds caching and controller endpoint</name>
  <files>
    Transcendence.Service.Core/Services/Analytics/Interfaces/IChampionAnalyticsService.cs
    Transcendence.Service.Core/Services/Analytics/Implementations/ChampionAnalyticsService.cs
    Transcendence.WebAPI/Controllers/ChampionAnalyticsController.cs
  </files>
  <action>
    1. **Add to IChampionAnalyticsService.cs**:
       ```csharp
       Task<ChampionBuildsResponse> GetBuildsAsync(
           int championId,
           string role,
           string? rankTier,
           CancellationToken ct);
       ```

    2. **Add to ChampionAnalyticsService.cs**:
       ```csharp
       private const string BuildsCacheKeyPrefix = "analytics:builds:";

       public async Task<ChampionBuildsResponse> GetBuildsAsync(
           int championId,
           string role,
           string? rankTier,
           CancellationToken ct)
       {
           var patch = await GetCurrentPatchAsync(ct);
           var normalizedRole = role.ToUpperInvariant();
           var normalizedTier = rankTier ?? "all";
           var cacheKey = $"{BuildsCacheKeyPrefix}{championId}:{normalizedRole}:{normalizedTier}:{patch}";
           var tags = new[] { "analytics", $"patch:{patch}", "builds" };

           return await cache.GetOrCreateAsync(
               cacheKey,
               async cancel => await computeService.ComputeBuildsAsync(
                   championId, normalizedRole, rankTier, patch, cancel),
               AnalyticsCacheOptions,
               tags,
               cancellationToken: ct);
       }
       ```

    3. **Add to ChampionAnalyticsController.cs**:
       ```csharp
       /// <summary>
       /// Get top 3 builds for a champion in a role.
       /// Builds include items and runes bundled together.
       /// Core items (70%+ appearance) are distinguished from situational.
       /// </summary>
       /// <param name="championId">Champion ID</param>
       /// <param name="role">Role: TOP, JUNGLE, MIDDLE, BOTTOM, UTILITY</param>
       /// <param name="rankTier">Optional: Filter by rank tier</param>
       [HttpGet("champions/{championId}/builds")]
       public async Task<ActionResult<ChampionBuildsResponse>> GetBuilds(
           int championId,
           [FromQuery] string role,
           [FromQuery] string? rankTier = null,
           CancellationToken ct = default)
       {
           if (string.IsNullOrEmpty(role))
               return BadRequest("Role parameter is required");

           var result = await analyticsService.GetBuildsAsync(championId, role, rankTier, ct);
           return Ok(result);
       }
       ```
  </action>
  <verify>
    Build: `dotnet build Transcendence.sln`
  </verify>
  <done>Builds endpoint returns top 3 builds with items+runes bundled, core/situational distinguished</done>
</task>

</tasks>

<verification>
1. `dotnet build Transcendence.sln` succeeds
2. ChampionBuildDto contains Items, CoreItems, SituationalItems, rune structure
3. Builds grouped by item+rune combination (bundled per user decision)
4. Core items threshold = 70% appearance rate
5. Excluded from core: boots (3006, 3009, 3020, 3047, 3111, 3117, 3158, 1001), trinkets (3340, 3363, 3364), consumables (2003, 2031, 2033, 2055, 2138, 2139, 2140)
6. Top 3 builds returned ordered by (games * winRate)
7. Minimum 30 games per specific build combination
</verification>

<success_criteria>
- Top 3 builds per champion/role returned with items and runes bundled
- Core items (70%+ appearance) clearly distinguished from situational
- Boots, trinkets, consumables excluded from core item calculation
- Build scoring balances popularity (games) with effectiveness (win rate)
- Results cached for 24 hours
- Skill order marked as limitation (requires Timeline API not yet fetched)
</success_criteria>

<output>
After completion, create `.planning/phases/03-champion-analytics/03-03-SUMMARY.md`
</output>
