---
phase: 03-champion-analytics
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - Transcendence.Service.Core/Services/Analytics/Models/TierListDto.cs
  - Transcendence.Service.Core/Services/Analytics/Interfaces/IChampionAnalyticsComputeService.cs
  - Transcendence.Service.Core/Services/Analytics/Interfaces/IChampionAnalyticsService.cs
  - Transcendence.Service.Core/Services/Analytics/Implementations/ChampionAnalyticsComputeService.cs
  - Transcendence.Service.Core/Services/Analytics/Implementations/ChampionAnalyticsService.cs
  - Transcendence.WebAPI/Controllers/ChampionAnalyticsController.cs
autonomous: true

must_haves:
  truths:
    - "GET /api/analytics/tierlist returns champions ranked S/A/B/C/D by composite score"
    - "Tier lists show movement indicators (UP/DOWN/SAME/NEW) from previous patch"
    - "Composite score combines win rate (70%) and pick rate (30%)"
    - "Both per-role and unified tier lists are available"
  artifacts:
    - path: "Transcendence.Service.Core/Services/Analytics/Models/TierListDto.cs"
      provides: "Tier list entry with grade, score, movement"
      exports: ["TierListEntry", "TierListResponse"]
    - path: "Transcendence.WebAPI/Controllers/ChampionAnalyticsController.cs"
      provides: "Tier list REST endpoint"
      exports: ["GET /api/analytics/tierlist"]
  key_links:
    - from: "ChampionAnalyticsComputeService"
      to: "MatchParticipants GroupBy"
      via: "EF Core aggregate with percentile ranking"
      pattern: "OrderByDescending.*CompositeScore"
    - from: "TierListEntry"
      to: "Previous patch comparison"
      via: "LEFT JOIN equivalent for movement calculation"
      pattern: "Movement = "
---

<objective>
Implement champion tier lists with S/A/B/C/D grades based on composite score (win rate + pick rate) and movement indicators from previous patch (CHAMP-03).

Purpose: Provide ranked tier lists per role that help users understand meta strength using both win rate and pick rate as factors.

Output: Working `/api/analytics/tierlist` endpoint returning percentile-based tier assignments with movement tracking.
</objective>

<execution_context>
@C:\Users\luigon\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\luigon\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-champion-analytics/03-CONTEXT.md
@.planning/phases/03-champion-analytics/03-RESEARCH.md
@.planning/phases/03-champion-analytics/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tier list DTOs</name>
  <files>
    Transcendence.Service.Core/Services/Analytics/Models/TierListDto.cs
  </files>
  <action>
    Create DTOs for tier list responses:

    ```csharp
    namespace Transcendence.Service.Core.Services.Analytics.Models;

    /// <summary>
    /// Individual champion entry in a tier list.
    /// </summary>
    public record TierListEntry(
        int ChampionId,
        string Tier,              // S, A, B, C, D
        int Rank,                 // 1-based position in tier list
        double WinRate,           // 0.0 to 1.0
        double PickRate,          // 0.0 to 1.0
        double CompositeScore,    // 0.0 to 1.0 (weighted: 70% WR + 30% PR normalized)
        int Games,
        string Movement,          // UP, DOWN, SAME, NEW
        string? PreviousTier      // Tier from previous patch (null if NEW)
    );

    /// <summary>
    /// Tier list grouped by grade.
    /// </summary>
    public record TierListResponse(
        string Role,              // TOP, JUNGLE, MIDDLE, BOTTOM, UTILITY, or "ALL" for unified
        string RankTier,          // Filter tier or "all"
        string Patch,
        List<TierListEntry> STier,
        List<TierListEntry> ATier,
        List<TierListEntry> BTier,
        List<TierListEntry> CTier,
        List<TierListEntry> DTier
    );
    ```
  </action>
  <verify>File exists: `type Transcendence.Service.Core\Services\Analytics\Models\TierListDto.cs`</verify>
  <done>TierListEntry includes movement indicator and previous tier for UI display</done>
</task>

<task type="auto">
  <name>Task 2: Implement tier list computation with percentile-based grading</name>
  <files>
    Transcendence.Service.Core/Services/Analytics/Interfaces/IChampionAnalyticsComputeService.cs
    Transcendence.Service.Core/Services/Analytics/Implementations/ChampionAnalyticsComputeService.cs
  </files>
  <action>
    1. **Add to IChampionAnalyticsComputeService.cs**:
       ```csharp
       Task<List<TierListEntry>> ComputeTierListAsync(
           string role,
           string? rankTier,
           string patch,
           CancellationToken ct);
       ```

    2. **Add to ChampionAnalyticsComputeService.cs**:
       ```csharp
       public async Task<List<TierListEntry>> ComputeTierListAsync(
           string role,
           string? rankTier,
           string patch,
           CancellationToken ct)
       {
           // Step 1: Aggregate champion stats for this role/tier/patch
           var baseQuery = db.MatchParticipants
               .AsNoTracking()
               .Where(mp => mp.Match.Patch == patch
                         && mp.Match.Status == FetchStatus.Success);

           // Apply role filter (unless unified "ALL")
           if (role != "ALL")
               baseQuery = baseQuery.Where(mp => mp.TeamPosition == role);

           // Join with Rank for tier filtering
           var joinedQuery = baseQuery
               .Join(
                   db.Ranks.Where(r => r.QueueType == "RANKED_SOLO_5x5"
                       && (string.IsNullOrEmpty(rankTier) || r.Tier == rankTier)),
                   mp => mp.SummonerId,
                   r => r.SummonerId,
                   (mp, r) => mp
               );

           var championStats = await joinedQuery
               .GroupBy(mp => mp.ChampionId)
               .Select(g => new
               {
                   ChampionId = g.Key,
                   Games = g.Count(),
                   Wins = g.Sum(x => x.Win ? 1 : 0)
               })
               .Where(x => x.Games >= MinimumGamesRequired)
               .ToListAsync(ct);

           if (championStats.Count == 0)
               return new List<TierListEntry>();

           // Step 2: Compute total games for pick rate calculation
           var totalGames = await joinedQuery
               .Select(mp => mp.MatchId)
               .Distinct()
               .CountAsync(ct);

           // Step 3: Calculate composite scores
           var withScores = championStats.Select(c => new
           {
               c.ChampionId,
               c.Games,
               c.Wins,
               WinRate = c.Games > 0 ? (double)c.Wins / c.Games : 0.0,
               PickRate = totalGames > 0 ? (double)c.Games / totalGames : 0.0
           })
           .Select(c => new
           {
               c.ChampionId,
               c.Games,
               c.WinRate,
               c.PickRate,
               // Composite: 70% win rate + 30% pick rate (normalized)
               CompositeScore = (c.WinRate * 0.70) + (c.PickRate * 0.30)
           })
           .OrderByDescending(x => x.CompositeScore)
           .ToList();

           // Step 4: Get previous patch tier list for movement comparison
           var previousPatch = await GetPreviousPatchAsync(patch, ct);
           var previousTiers = previousPatch != null
               ? await GetPreviousPatchTiersAsync(role, rankTier, previousPatch, ct)
               : new Dictionary<int, string>();

           // Step 5: Assign percentile-based tiers
           // Top 10% = S, 10-30% = A, 30-60% = B, 60-85% = C, 85%+ = D
           var total = withScores.Count;
           return withScores.Select((entry, index) =>
           {
               var percentile = (double)index / total;
               var tier = percentile switch
               {
                   < 0.10 => "S",
                   < 0.30 => "A",
                   < 0.60 => "B",
                   < 0.85 => "C",
                   _ => "D"
               };

               // Calculate movement from previous patch
               var previousTier = previousTiers.GetValueOrDefault(entry.ChampionId);
               var movement = CalculateMovement(tier, previousTier);

               return new TierListEntry(
                   entry.ChampionId,
                   tier,
                   index + 1,  // 1-based rank
                   entry.WinRate,
                   entry.PickRate,
                   entry.CompositeScore,
                   entry.Games,
                   movement,
                   previousTier
               );
           }).ToList();
       }

       private async Task<string?> GetPreviousPatchAsync(string currentPatch, CancellationToken ct)
       {
           // Get all patches ordered by release date, find the one before current
           var patches = await db.Patches
               .AsNoTracking()
               .OrderByDescending(p => p.ReleaseDate)
               .Select(p => p.Version)
               .Take(5)
               .ToListAsync(ct);

           var currentIndex = patches.IndexOf(currentPatch);
           return currentIndex >= 0 && currentIndex + 1 < patches.Count
               ? patches[currentIndex + 1]
               : null;
       }

       private async Task<Dictionary<int, string>> GetPreviousPatchTiersAsync(
           string role,
           string? rankTier,
           string patch,
           CancellationToken ct)
       {
           // Simplified query - just need champion -> tier mapping
           var previousList = await ComputeTierListAsync(role, rankTier, patch, ct);
           return previousList.ToDictionary(e => e.ChampionId, e => e.Tier);
       }

       private static string CalculateMovement(string currentTier, string? previousTier)
       {
           if (string.IsNullOrEmpty(previousTier))
               return "NEW";

           var currentValue = TierToValue(currentTier);
           var previousValue = TierToValue(previousTier);

           return (currentValue - previousValue) switch
           {
               > 0 => "UP",
               < 0 => "DOWN",
               _ => "SAME"
           };
       }

       private static int TierToValue(string tier) => tier switch
       {
           "S" => 5,
           "A" => 4,
           "B" => 3,
           "C" => 2,
           "D" => 1,
           _ => 0
       };
       ```
  </action>
  <verify>Build: `dotnet build Transcendence.Service.Core`</verify>
  <done>Tier list computation uses percentile-based S/A/B/C/D with composite scoring and movement tracking</done>
</task>

<task type="auto">
  <name>Task 3: Add tier list caching and controller endpoint</name>
  <files>
    Transcendence.Service.Core/Services/Analytics/Interfaces/IChampionAnalyticsService.cs
    Transcendence.Service.Core/Services/Analytics/Implementations/ChampionAnalyticsService.cs
    Transcendence.WebAPI/Controllers/ChampionAnalyticsController.cs
  </files>
  <action>
    1. **Add to IChampionAnalyticsService.cs**:
       ```csharp
       Task<TierListResponse> GetTierListAsync(
           string role,
           string? rankTier,
           CancellationToken ct);
       ```

    2. **Add to ChampionAnalyticsService.cs**:
       ```csharp
       private const string TierListCacheKeyPrefix = "analytics:tierlist:";

       public async Task<TierListResponse> GetTierListAsync(
           string role,
           string? rankTier,
           CancellationToken ct)
       {
           var patch = await GetCurrentPatchAsync(ct);
           var normalizedRole = string.IsNullOrEmpty(role) ? "ALL" : role.ToUpperInvariant();
           var normalizedTier = rankTier ?? "all";
           var cacheKey = $"{TierListCacheKeyPrefix}{normalizedRole}:{normalizedTier}:{patch}";
           var tags = new[] { "analytics", $"patch:{patch}", "tierlist" };

           var entries = await cache.GetOrCreateAsync(
               cacheKey,
               async cancel => await computeService.ComputeTierListAsync(
                   normalizedRole, rankTier, patch, cancel),
               AnalyticsCacheOptions,
               tags,
               cancellationToken: ct);

           // Group into tiers for response
           return new TierListResponse(
               normalizedRole,
               normalizedTier,
               patch,
               entries.Where(e => e.Tier == "S").ToList(),
               entries.Where(e => e.Tier == "A").ToList(),
               entries.Where(e => e.Tier == "B").ToList(),
               entries.Where(e => e.Tier == "C").ToList(),
               entries.Where(e => e.Tier == "D").ToList()
           );
       }
       ```

    3. **Add to ChampionAnalyticsController.cs**:
       ```csharp
       /// <summary>
       /// Get champion tier list for a role.
       /// </summary>
       /// <param name="role">Role: TOP, JUNGLE, MIDDLE, BOTTOM, UTILITY, or empty for unified</param>
       /// <param name="rankTier">Optional: Filter by rank tier</param>
       [HttpGet("tierlist")]
       public async Task<ActionResult<TierListResponse>> GetTierList(
           [FromQuery] string? role = null,
           [FromQuery] string? rankTier = null,
           CancellationToken ct = default)
       {
           var result = await analyticsService.GetTierListAsync(role ?? "ALL", rankTier, ct);
           return Ok(result);
       }
       ```
  </action>
  <verify>
    Build: `dotnet build Transcendence.sln`
  </verify>
  <done>Tier list endpoint returns S/A/B/C/D grouped champions with movement indicators</done>
</task>

</tasks>

<verification>
1. `dotnet build Transcendence.sln` succeeds
2. TierListDto contains Tier (S/A/B/C/D), CompositeScore, Movement, PreviousTier
3. Composite score = 70% win rate + 30% pick rate
4. Percentile thresholds: S < 10%, A < 30%, B < 60%, C < 85%, D >= 85%
5. Movement calculated from previous patch comparison
6. Endpoint accepts role and rankTier query parameters
7. Empty role returns unified tier list (all roles combined)
</verification>

<success_criteria>
- Tier lists rank champions using composite score (win rate 70%, pick rate 30%)
- S/A/B/C/D grades assigned by percentile position (top 10% = S, etc.)
- Movement indicators show tier change from previous patch (UP/DOWN/SAME/NEW)
- Per-role tier lists available (default), unified list available with role=ALL
- Results cached for 24 hours
</success_criteria>

<output>
After completion, create `.planning/phases/03-champion-analytics/03-02-SUMMARY.md`
</output>
