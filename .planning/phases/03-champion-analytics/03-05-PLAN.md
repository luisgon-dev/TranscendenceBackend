---
phase: 03-champion-analytics
plan: 05
type: execute
wave: 3
depends_on: ["03-01", "03-02", "03-03", "03-04"]
files_modified:
  - Transcendence.Service.Core/Services/Jobs/RefreshChampionAnalyticsJob.cs
  - Transcendence.Service.Core/Services/Extensions/HangfireExtensions.cs
  - Transcendence.Service/Program.cs
autonomous: true

must_haves:
  truths:
    - "Daily analytics refresh job runs at 4 AM UTC"
    - "Job invalidates all analytics cache tags before recomputing"
    - "Job pre-warms cache for popular champions/roles"
    - "Hangfire dashboard shows analytics refresh job status"
  artifacts:
    - path: "Transcendence.Service.Core/Services/Jobs/RefreshChampionAnalyticsJob.cs"
      provides: "Daily analytics refresh with cache pre-warming"
      min_lines: 40
    - path: "Transcendence.Service.Core/Services/Extensions/HangfireExtensions.cs"
      provides: "Hangfire job scheduling"
      contains: "RefreshChampionAnalyticsJob"
  key_links:
    - from: "RefreshChampionAnalyticsJob"
      to: "IChampionAnalyticsService.InvalidateAnalyticsCacheAsync"
      via: "Cache invalidation before refresh"
      pattern: "InvalidateAnalyticsCacheAsync"
    - from: "Hangfire"
      to: "RefreshChampionAnalyticsJob"
      via: "RecurringJob.AddOrUpdate"
      pattern: "RecurringJob.AddOrUpdate"
---

<objective>
Implement daily analytics refresh job with cache invalidation and pre-warming for popular champions/roles (Phase 3 operational support).

Purpose: Ensure analytics stay fresh with daily updates at low-traffic hours while minimizing cold-cache latency for users via pre-warming.

Output: Working Hangfire job that runs daily at 4 AM UTC to refresh analytics cache.
</objective>

<execution_context>
@C:\Users\luigon\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\luigon\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-champion-analytics/03-CONTEXT.md
@.planning/phases/03-champion-analytics/03-RESEARCH.md
@.planning/phases/03-champion-analytics/03-01-SUMMARY.md
@Transcendence.Service.Core/Services/Jobs/UpdateStaticDataJob.cs (existing job pattern)
@Transcendence.Service.Core/Services/Extensions/HangfireExtensions.cs (job registration)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RefreshChampionAnalyticsJob</name>
  <files>
    Transcendence.Service.Core/Services/Jobs/RefreshChampionAnalyticsJob.cs
  </files>
  <action>
    Create the daily analytics refresh job:

    ```csharp
    using Microsoft.EntityFrameworkCore;
    using Microsoft.Extensions.Logging;
    using Transcendence.Data;
    using Transcendence.Service.Core.Services.Analytics.Interfaces;
    using Transcendence.Service.Core.Services.Analytics.Models;

    namespace Transcendence.Service.Core.Services.Jobs;

    /// <summary>
    /// Daily job to refresh champion analytics cache.
    /// Runs at 4 AM UTC to minimize user impact.
    /// </summary>
    public class RefreshChampionAnalyticsJob(
        IChampionAnalyticsService analyticsService,
        TranscendenceContext db,
        ILogger<RefreshChampionAnalyticsJob> logger)
    {
        // Popular roles to pre-warm
        private static readonly string[] Roles = { "TOP", "JUNGLE", "MIDDLE", "BOTTOM", "UTILITY" };

        // Primary rank tiers to pre-warm (covers majority of player base)
        private static readonly string[] PrimaryTiers = { "Gold", "Platinum", "Emerald", "Diamond" };

        public async Task ExecuteAsync(CancellationToken ct)
        {
            logger.LogInformation("Starting daily champion analytics refresh");
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();

            try
            {
                // Step 1: Invalidate all analytics cache
                logger.LogInformation("Invalidating analytics cache");
                await analyticsService.InvalidateAnalyticsCacheAsync(ct);

                // Step 2: Get popular champions to pre-warm
                // Popular = most games played in recent matches
                var popularChampions = await GetPopularChampionsAsync(ct);
                logger.LogInformation("Pre-warming cache for {Count} popular champions", popularChampions.Count);

                // Step 3: Pre-warm tier lists (high value, relatively few combinations)
                foreach (var role in Roles)
                {
                    foreach (var tier in PrimaryTiers)
                    {
                        try
                        {
                            await analyticsService.GetTierListAsync(role, tier, ct);
                            logger.LogDebug("Pre-warmed tier list: {Role}/{Tier}", role, tier);
                        }
                        catch (Exception ex)
                        {
                            logger.LogWarning(ex, "Failed to pre-warm tier list {Role}/{Tier}", role, tier);
                        }
                    }

                    // Also pre-warm "all tiers" tier list per role
                    try
                    {
                        await analyticsService.GetTierListAsync(role, null, ct);
                        logger.LogDebug("Pre-warmed tier list: {Role}/all", role);
                    }
                    catch (Exception ex)
                    {
                        logger.LogWarning(ex, "Failed to pre-warm tier list {Role}/all", role);
                    }
                }

                // Step 4: Pre-warm unified tier list
                try
                {
                    await analyticsService.GetTierListAsync("ALL", null, ct);
                    logger.LogDebug("Pre-warmed unified tier list");
                }
                catch (Exception ex)
                {
                    logger.LogWarning(ex, "Failed to pre-warm unified tier list");
                }

                // Step 5: Pre-warm win rates, builds, matchups for top 20 champions per role
                var preWarmCount = 0;
                foreach (var role in Roles)
                {
                    var roleChampions = popularChampions
                        .Where(c => c.Role == role)
                        .Take(20)
                        .ToList();

                    foreach (var champ in roleChampions)
                    {
                        try
                        {
                            // Pre-warm with "all" tier filter (most common query)
                            await analyticsService.GetWinRatesAsync(
                                champ.ChampionId,
                                new ChampionAnalyticsFilter(Role: role),
                                ct);

                            await analyticsService.GetBuildsAsync(champ.ChampionId, role, null, ct);
                            await analyticsService.GetMatchupsAsync(champ.ChampionId, role, null, ct);

                            preWarmCount++;
                            logger.LogDebug("Pre-warmed analytics for champion {ChampId} in {Role}",
                                champ.ChampionId, role);
                        }
                        catch (Exception ex)
                        {
                            logger.LogWarning(ex, "Failed to pre-warm analytics for champion {ChampId} in {Role}",
                                champ.ChampionId, role);
                        }
                    }
                }

                stopwatch.Stop();
                logger.LogInformation(
                    "Analytics refresh complete. Pre-warmed {Count} champion/role combinations in {Elapsed}ms",
                    preWarmCount,
                    stopwatch.ElapsedMilliseconds);
            }
            catch (Exception ex)
            {
                stopwatch.Stop();
                logger.LogError(ex, "Analytics refresh failed after {Elapsed}ms", stopwatch.ElapsedMilliseconds);
                throw;
            }
        }

        private async Task<List<(int ChampionId, string Role, int Games)>> GetPopularChampionsAsync(
            CancellationToken ct)
        {
            // Get current patch
            var currentPatch = await db.Patches
                .AsNoTracking()
                .Where(p => p.IsActive)
                .Select(p => p.Version)
                .FirstOrDefaultAsync(ct);

            if (string.IsNullOrEmpty(currentPatch))
            {
                logger.LogWarning("No active patch found, skipping popular champion lookup");
                return new List<(int, string, int)>();
            }

            // Get top champions by games played per role
            var popular = await db.MatchParticipants
                .AsNoTracking()
                .Where(mp => mp.Match.Patch == currentPatch
                          && mp.Match.Status == Data.Models.LoL.Match.FetchStatus.Success
                          && mp.TeamPosition != null)
                .GroupBy(mp => new { mp.ChampionId, mp.TeamPosition })
                .Select(g => new
                {
                    g.Key.ChampionId,
                    Role = g.Key.TeamPosition!,
                    Games = g.Count()
                })
                .OrderByDescending(x => x.Games)
                .Take(100) // Top 100 champion/role combinations (20 per role)
                .ToListAsync(ct);

            return popular.Select(p => (p.ChampionId, p.Role, p.Games)).ToList();
        }
    }
    ```
  </action>
  <verify>File exists: `type Transcendence.Service.Core\Services\Jobs\RefreshChampionAnalyticsJob.cs`</verify>
  <done>Analytics refresh job invalidates cache and pre-warms popular champions/roles</done>
</task>

<task type="auto">
  <name>Task 2: Register job in DI and schedule with Hangfire</name>
  <files>
    Transcendence.Service.Core/Services/Extensions/HangfireExtensions.cs
    Transcendence.Service/Program.cs
  </files>
  <action>
    1. **Update HangfireExtensions.cs** - Add recurring job registration:
       ```csharp
       // Add after existing job registrations
       RecurringJob.AddOrUpdate<RefreshChampionAnalyticsJob>(
           "refresh-champion-analytics",
           job => job.ExecuteAsync(CancellationToken.None),
           "0 4 * * *", // 4 AM UTC daily
           new RecurringJobOptions { TimeZone = TimeZoneInfo.Utc }
       );
       ```

       Add using if not present:
       ```csharp
       using Transcendence.Service.Core.Services.Jobs;
       ```

    2. **Update Program.cs in Transcendence.Service** - Register job in DI:
       ```csharp
       // Add to service registrations (after AddTranscendenceCore or AddTranscendenceRiot)
       services.AddScoped<RefreshChampionAnalyticsJob>();
       ```

       Or add to ServiceCollectionExtensions.cs if preferred:
       In `AddTranscendenceCore`:
       ```csharp
       services.AddScoped<RefreshChampionAnalyticsJob>();
       ```

    **Schedule rationale:**
    - 4 AM UTC chosen as low-traffic time globally
    - Daily refresh aligns with 24hr cache TTL
    - Job runs in background, doesn't block user requests
    - Pre-warming ensures most common queries are instant
  </action>
  <verify>
    Build: `dotnet build Transcendence.sln`
    Check schedule registered: look for "refresh-champion-analytics" in code
  </verify>
  <done>Analytics refresh job scheduled for 4 AM UTC daily with Hangfire</done>
</task>

<task type="auto">
  <name>Task 3: Add manual refresh endpoint for admins</name>
  <files>
    Transcendence.WebAPI/Controllers/ChampionAnalyticsController.cs
  </files>
  <action>
    Add admin endpoint to trigger manual refresh (useful for testing and operational needs):

    ```csharp
    /// <summary>
    /// [Admin] Invalidate all analytics cache.
    /// Triggers cache refresh on next request.
    /// </summary>
    /// <remarks>
    /// This endpoint invalidates cache but does not pre-warm.
    /// For full refresh with pre-warming, use Hangfire dashboard to trigger the job.
    /// TODO: Add admin authentication in Phase 4.
    /// </remarks>
    [HttpPost("cache/invalidate")]
    public async Task<IActionResult> InvalidateCache(CancellationToken ct = default)
    {
        await analyticsService.InvalidateAnalyticsCacheAsync(ct);
        return Ok(new { message = "Analytics cache invalidated. Data will refresh on next request." });
    }
    ```

    **Note:** Authentication will be added in Phase 4 (AUTH-01, AUTH-02). For now, this endpoint is unprotected. In production, restrict access via network policy or add basic auth header check.
  </action>
  <verify>
    Build: `dotnet build Transcendence.sln`
  </verify>
  <done>Manual cache invalidation endpoint available for operational needs</done>
</task>

</tasks>

<verification>
1. `dotnet build Transcendence.sln` succeeds
2. RefreshChampionAnalyticsJob.cs exists with ExecuteAsync method
3. Job registered in HangfireExtensions with "0 4 * * *" cron expression (4 AM UTC)
4. Job registered in DI (AddScoped)
5. Job flow:
   - Invalidates cache via RemoveByTagAsync("analytics")
   - Pre-warms tier lists for all roles x primary tiers
   - Pre-warms top 20 champions per role (win rates, builds, matchups)
6. Manual invalidation endpoint exists at POST /api/analytics/cache/invalidate
</verification>

<success_criteria>
- Daily job runs at 4 AM UTC to refresh analytics
- Cache invalidation happens before new data is computed
- Popular champions/roles are pre-warmed for instant responses
- Tier lists pre-warmed for common role/tier combinations
- Job visible in Hangfire dashboard for monitoring
- Manual invalidation available for admin operations
</success_criteria>

<output>
After completion, create `.planning/phases/03-champion-analytics/03-05-SUMMARY.md`
</output>
