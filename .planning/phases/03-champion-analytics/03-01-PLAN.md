---
phase: 03-champion-analytics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Transcendence.Service.Core/Services/Analytics/Models/ChampionWinRateDto.cs
  - Transcendence.Service.Core/Services/Analytics/Models/ChampionAnalyticsFilter.cs
  - Transcendence.Service.Core/Services/Analytics/Interfaces/IChampionAnalyticsService.cs
  - Transcendence.Service.Core/Services/Analytics/Interfaces/IChampionAnalyticsComputeService.cs
  - Transcendence.Service.Core/Services/Analytics/Implementations/ChampionAnalyticsComputeService.cs
  - Transcendence.Service.Core/Services/Analytics/Implementations/ChampionAnalyticsService.cs
  - Transcendence.Service.Core/Services/Extensions/ServiceCollectionExtensions.cs
  - Transcendence.WebAPI/Controllers/ChampionAnalyticsController.cs
autonomous: true

must_haves:
  truths:
    - "GET /api/analytics/champions/{championId}/winrates returns win rate data by role and rank tier"
    - "Win rates only shown for champion/role combinations with 100+ games"
    - "Analytics are cached for 24 hours with 1hr L1"
    - "Current patch data only (no fallback to previous patches)"
  artifacts:
    - path: "Transcendence.Service.Core/Services/Analytics/Models/ChampionWinRateDto.cs"
      provides: "Win rate DTO with role, tier, games, wins, win rate"
      exports: ["ChampionWinRateDto", "ChampionWinRateSummary"]
    - path: "Transcendence.Service.Core/Services/Analytics/Implementations/ChampionAnalyticsComputeService.cs"
      provides: "Raw EF queries for aggregating match data"
      min_lines: 50
    - path: "Transcendence.WebAPI/Controllers/ChampionAnalyticsController.cs"
      provides: "Champion analytics REST endpoints"
      exports: ["GET /api/analytics/champions/{championId}/winrates"]
  key_links:
    - from: "ChampionAnalyticsController"
      to: "IChampionAnalyticsService"
      via: "DI injection"
      pattern: "IChampionAnalyticsService"
    - from: "ChampionAnalyticsService"
      to: "HybridCache"
      via: "GetOrCreateAsync with 24hr TTL"
      pattern: "cache.GetOrCreateAsync"
---

<objective>
Create analytics foundation infrastructure (DTOs, services, caching) and champion win rate endpoint (CHAMP-01).

Purpose: Establish the analytics service architecture that all subsequent analytics features will build upon, while delivering the first requirement (win rates by role/tier).

Output: Working `/api/analytics/champions/{championId}/winrates` endpoint with 24hr cache and compute service foundation.
</objective>

<execution_context>
@C:\Users\luigon\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\luigon\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-champion-analytics/03-CONTEXT.md
@.planning/phases/03-champion-analytics/03-RESEARCH.md
@Transcendence.Service.Core/Services/Analysis/Implementations/SummonerStatsService.cs (caching pattern)
@Transcendence.Service.Core/Services/Extensions/ServiceCollectionExtensions.cs (DI registration)
@Transcendence.Data/Models/LoL/Match/MatchParticipant.cs (data model)
@Transcendence.Data/Models/LoL/Account/Rank.cs (rank tier model)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create analytics DTOs and service interfaces</name>
  <files>
    Transcendence.Service.Core/Services/Analytics/Models/ChampionWinRateDto.cs
    Transcendence.Service.Core/Services/Analytics/Models/ChampionAnalyticsFilter.cs
    Transcendence.Service.Core/Services/Analytics/Interfaces/IChampionAnalyticsService.cs
    Transcendence.Service.Core/Services/Analytics/Interfaces/IChampionAnalyticsComputeService.cs
  </files>
  <action>
    Create the analytics models directory and DTOs:

    1. **ChampionAnalyticsFilter.cs** - Query filter record:
       ```csharp
       public record ChampionAnalyticsFilter(
           string? RankTier = null,    // Iron, Bronze, Silver, Gold, Platinum, Emerald, Diamond, Master, Grandmaster, Challenger
           string? Region = null,       // Optional region filter (default: global)
           string? Role = null          // TOP, JUNGLE, MIDDLE, BOTTOM, UTILITY
       );
       ```

    2. **ChampionWinRateDto.cs** - Win rate DTOs:
       ```csharp
       public record ChampionWinRateDto(
           int ChampionId,
           string Role,
           string RankTier,
           int Games,
           int Wins,
           double WinRate,              // 0.0 to 1.0
           double PickRate,             // 0.0 to 1.0
           string Patch
       );

       public record ChampionWinRateSummary(
           int ChampionId,
           string Patch,
           List<ChampionWinRateDto> ByRoleTier
       );
       ```

    3. **IChampionAnalyticsComputeService.cs** - Raw computation interface:
       ```csharp
       public interface IChampionAnalyticsComputeService
       {
           Task<List<ChampionWinRateDto>> ComputeWinRatesAsync(
               int championId,
               ChampionAnalyticsFilter filter,
               string patch,
               CancellationToken ct);
       }
       ```

    4. **IChampionAnalyticsService.cs** - Cached reads interface:
       ```csharp
       public interface IChampionAnalyticsService
       {
           Task<ChampionWinRateSummary> GetWinRatesAsync(
               int championId,
               ChampionAnalyticsFilter filter,
               CancellationToken ct);

           Task InvalidateAnalyticsCacheAsync(CancellationToken ct);
       }
       ```
  </action>
  <verify>Files exist with correct structure: `dir Transcendence.Service.Core\Services\Analytics\`</verify>
  <done>DTOs define win rate response shape, interfaces define service contracts</done>
</task>

<task type="auto">
  <name>Task 2: Implement ChampionAnalyticsComputeService with EF aggregation</name>
  <files>
    Transcendence.Service.Core/Services/Analytics/Implementations/ChampionAnalyticsComputeService.cs
  </files>
  <action>
    Create the compute service that performs raw EF Core aggregation queries:

    ```csharp
    public class ChampionAnalyticsComputeService(TranscendenceContext db) : IChampionAnalyticsComputeService
    {
        private const int MinimumGamesRequired = 100;

        public async Task<List<ChampionWinRateDto>> ComputeWinRatesAsync(
            int championId,
            ChampionAnalyticsFilter filter,
            string patch,
            CancellationToken ct)
        {
            // Base query: match participants for this champion on current patch
            var query = db.MatchParticipants
                .AsNoTracking()
                .Where(mp => mp.ChampionId == championId
                          && mp.Match.Patch == patch
                          && mp.Match.Status == FetchStatus.Success);

            // Apply role filter if specified
            if (!string.IsNullOrEmpty(filter.Role))
                query = query.Where(mp => mp.TeamPosition == filter.Role);

            // Apply rank tier filter via join to Summoner.Ranks
            // Note: Rank is stored on Summoner, need join
            IQueryable<(MatchParticipant mp, string tier)> joinedQuery;
            if (!string.IsNullOrEmpty(filter.RankTier))
            {
                joinedQuery = query
                    .Join(
                        db.Ranks.Where(r => r.Tier == filter.RankTier && r.QueueType == "RANKED_SOLO_5x5"),
                        mp => mp.SummonerId,
                        r => r.SummonerId,
                        (mp, r) => new { mp, tier = r.Tier }
                    )
                    .Select(x => ValueTuple.Create(x.mp, x.tier));
            }
            else
            {
                // All ranks - join without filter
                joinedQuery = query
                    .Join(
                        db.Ranks.Where(r => r.QueueType == "RANKED_SOLO_5x5"),
                        mp => mp.SummonerId,
                        r => r.SummonerId,
                        (mp, r) => new { mp, tier = r.Tier }
                    )
                    .Select(x => ValueTuple.Create(x.mp, x.tier));
            }

            // Group by role and rank tier, compute aggregates
            var aggregated = await joinedQuery
                .GroupBy(x => new { Role = x.Item1.TeamPosition ?? "UNKNOWN", RankTier = x.Item2 })
                .Select(g => new
                {
                    g.Key.Role,
                    g.Key.RankTier,
                    Games = g.Count(),
                    Wins = g.Sum(x => x.Item1.Win ? 1 : 0)
                })
                .Where(x => x.Games >= MinimumGamesRequired)
                .ToListAsync(ct);

            // Compute pick rate (requires total games per role/tier)
            var totalGamesByRoleTier = await db.MatchParticipants
                .AsNoTracking()
                .Where(mp => mp.Match.Patch == patch && mp.Match.Status == FetchStatus.Success)
                .Join(
                    db.Ranks.Where(r => r.QueueType == "RANKED_SOLO_5x5"),
                    mp => mp.SummonerId,
                    r => r.SummonerId,
                    (mp, r) => new { Role = mp.TeamPosition ?? "UNKNOWN", Tier = r.Tier, MatchId = mp.MatchId }
                )
                .GroupBy(x => new { x.Role, x.Tier })
                .Select(g => new { g.Key.Role, g.Key.Tier, Total = g.Select(x => x.MatchId).Distinct().Count() })
                .ToDictionaryAsync(x => (x.Role, x.Tier), x => x.Total, ct);

            return aggregated.Select(a => new ChampionWinRateDto(
                championId,
                a.Role,
                a.RankTier,
                a.Games,
                a.Wins,
                a.Games > 0 ? (double)a.Wins / a.Games : 0.0,
                totalGamesByRoleTier.TryGetValue((a.Role, a.RankTier), out var total) && total > 0
                    ? (double)a.Games / total
                    : 0.0,
                patch
            )).ToList();
        }
    }
    ```

    **Critical patterns:**
    - Use `AsNoTracking()` for read-only analytics
    - Join MatchParticipant with Rank via SummonerId for tier filtering
    - `MinimumGamesRequired = 100` per user decision
    - Return empty list if no data meets threshold
    - Current patch only (no fallback logic)
  </action>
  <verify>Build: `dotnet build Transcendence.Service.Core`</verify>
  <done>Compute service aggregates match data with 100-game minimum filter</done>
</task>

<task type="auto">
  <name>Task 3: Implement ChampionAnalyticsService with caching and controller endpoint</name>
  <files>
    Transcendence.Service.Core/Services/Analytics/Implementations/ChampionAnalyticsService.cs
    Transcendence.Service.Core/Services/Extensions/ServiceCollectionExtensions.cs
    Transcendence.WebAPI/Controllers/ChampionAnalyticsController.cs
  </files>
  <action>
    1. **ChampionAnalyticsService.cs** - Cached service wrapper:
       ```csharp
       public class ChampionAnalyticsService(
           TranscendenceContext db,
           HybridCache cache,
           IChampionAnalyticsComputeService computeService) : IChampionAnalyticsService
       {
           private const string WinRateCacheKeyPrefix = "analytics:winrate:";

           // Analytics: 24hr L2, 1hr L1 (daily refresh pattern)
           private static readonly HybridCacheEntryOptions AnalyticsCacheOptions = new()
           {
               Expiration = TimeSpan.FromHours(24),
               LocalCacheExpiration = TimeSpan.FromHours(1)
           };

           public async Task<ChampionWinRateSummary> GetWinRatesAsync(
               int championId,
               ChampionAnalyticsFilter filter,
               CancellationToken ct)
           {
               var patch = await GetCurrentPatchAsync(ct);
               var cacheKey = BuildWinRateCacheKey(championId, filter, patch);
               var tags = new[] { "analytics", $"patch:{patch}", "winrates" };

               var data = await cache.GetOrCreateAsync(
                   cacheKey,
                   async cancel => await computeService.ComputeWinRatesAsync(
                       championId, filter, patch, cancel),
                   AnalyticsCacheOptions,
                   tags,
                   cancellationToken: ct);

               return new ChampionWinRateSummary(championId, patch, data);
           }

           public async Task InvalidateAnalyticsCacheAsync(CancellationToken ct)
           {
               await cache.RemoveByTagAsync("analytics", ct);
           }

           private async Task<string> GetCurrentPatchAsync(CancellationToken ct)
           {
               var patch = await db.Patches
                   .AsNoTracking()
                   .Where(p => p.IsActive)
                   .Select(p => p.Version)
                   .FirstOrDefaultAsync(ct);
               return patch ?? "unknown";
           }

           private static string BuildWinRateCacheKey(int championId, ChampionAnalyticsFilter filter, string patch)
           {
               var tier = filter.RankTier ?? "all";
               var role = filter.Role ?? "all";
               var region = filter.Region ?? "global";
               return $"{WinRateCacheKeyPrefix}{championId}:{role}:{tier}:{region}:{patch}";
           }
       }
       ```

    2. **ServiceCollectionExtensions.cs** - Add DI registrations in `AddTranscendenceCore`:
       ```csharp
       services.AddScoped<IChampionAnalyticsComputeService, ChampionAnalyticsComputeService>();
       services.AddScoped<IChampionAnalyticsService, ChampionAnalyticsService>();
       ```
       Add using: `using Transcendence.Service.Core.Services.Analytics.Implementations;`
       And: `using Transcendence.Service.Core.Services.Analytics.Interfaces;`

    3. **ChampionAnalyticsController.cs** - REST endpoint:
       ```csharp
       using Microsoft.AspNetCore.Mvc;
       using Transcendence.Service.Core.Services.Analytics.Interfaces;
       using Transcendence.Service.Core.Services.Analytics.Models;

       namespace Transcendence.WebAPI.Controllers;

       [ApiController]
       [Route("api/analytics")]
       public class ChampionAnalyticsController(IChampionAnalyticsService analyticsService) : ControllerBase
       {
           /// <summary>
           /// Get champion win rates by role and rank tier.
           /// </summary>
           /// <param name="championId">Champion ID</param>
           /// <param name="role">Optional: TOP, JUNGLE, MIDDLE, BOTTOM, UTILITY</param>
           /// <param name="rankTier">Optional: Iron, Bronze, Silver, Gold, Platinum, Emerald, Diamond, Master, Grandmaster, Challenger</param>
           /// <param name="region">Optional: Region filter (default: global)</param>
           [HttpGet("champions/{championId}/winrates")]
           public async Task<ActionResult<ChampionWinRateSummary>> GetWinRates(
               int championId,
               [FromQuery] string? role = null,
               [FromQuery] string? rankTier = null,
               [FromQuery] string? region = null,
               CancellationToken ct = default)
           {
               var filter = new ChampionAnalyticsFilter(rankTier, region, role);
               var result = await analyticsService.GetWinRatesAsync(championId, filter, ct);
               return Ok(result);
           }
       }
       ```
  </action>
  <verify>
    Build and check endpoint registration:
    `dotnet build Transcendence.sln`
  </verify>
  <done>Win rate endpoint returns cached analytics with 24hr TTL, 100-game minimum filter, current patch only</done>
</task>

</tasks>

<verification>
1. `dotnet build Transcendence.sln` succeeds without errors
2. Files created in Analytics folder structure:
   - `Transcendence.Service.Core/Services/Analytics/Models/` contains DTOs
   - `Transcendence.Service.Core/Services/Analytics/Interfaces/` contains service interfaces
   - `Transcendence.Service.Core/Services/Analytics/Implementations/` contains service implementations
3. Controller endpoint `/api/analytics/champions/{championId}/winrates` exists
4. Cache options set to 24hr L2, 1hr L1
5. 100-game minimum filter applied in compute service
</verification>

<success_criteria>
- Analytics service infrastructure established for subsequent plans
- Win rate endpoint returns champion data segmented by role and rank tier
- Only champion/role/tier combinations with 100+ games are returned
- Data is cached for 24 hours with tag-based invalidation support
- Current patch data only (no fallback to previous patches)
</success_criteria>

<output>
After completion, create `.planning/phases/03-champion-analytics/03-01-SUMMARY.md`
</output>
