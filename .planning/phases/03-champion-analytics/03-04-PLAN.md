---
phase: 03-champion-analytics
plan: 04
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - Transcendence.Service.Core/Services/Analytics/Models/MatchupDto.cs
  - Transcendence.Service.Core/Services/Analytics/Interfaces/IChampionAnalyticsComputeService.cs
  - Transcendence.Service.Core/Services/Analytics/Interfaces/IChampionAnalyticsService.cs
  - Transcendence.Service.Core/Services/Analytics/Implementations/ChampionAnalyticsComputeService.cs
  - Transcendence.Service.Core/Services/Analytics/Implementations/ChampionAnalyticsService.cs
  - Transcendence.WebAPI/Controllers/ChampionAnalyticsController.cs
autonomous: true

must_haves:
  truths:
    - "GET /api/analytics/champions/{championId}/matchups returns counters and synergies"
    - "Matchups are lane-specific (Mid vs Mid, Top vs Top)"
    - "Shows top 5 counters and top 5 favorable matchups"
    - "Game count displayed for each matchup for reliability assessment"
    - "Minimum 30 games required per individual matchup"
  artifacts:
    - path: "Transcendence.Service.Core/Services/Analytics/Models/MatchupDto.cs"
      provides: "Matchup DTO with opponent, win rate, game count"
      exports: ["MatchupEntryDto", "ChampionMatchupsResponse"]
    - path: "Transcendence.WebAPI/Controllers/ChampionAnalyticsController.cs"
      provides: "Matchups endpoint"
      exports: ["GET /api/analytics/champions/{championId}/matchups"]
  key_links:
    - from: "ChampionAnalyticsComputeService"
      to: "MatchParticipants self-join"
      via: "Join opponent in same role different team"
      pattern: "TeamId != .* TeamPosition =="
    - from: "Matchup filtering"
      to: "Games threshold"
      via: "30 game minimum per matchup"
      pattern: ">= 30"
---

<objective>
Implement champion matchup data showing counters (bad matchups) and synergies (favorable matchups) with lane-specific filtering and game counts (CHAMP-04).

Purpose: Help users understand which champions counter or lose to a specific pick, enabling better draft decisions.

Output: Working `/api/analytics/champions/{championId}/matchups` endpoint returning top 5 counters and top 5 favorable matchups with game counts.
</objective>

<execution_context>
@C:\Users\luigon\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\luigon\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-champion-analytics/03-CONTEXT.md
@.planning/phases/03-champion-analytics/03-RESEARCH.md
@.planning/phases/03-champion-analytics/03-01-SUMMARY.md
@Transcendence.Data/Models/LoL/Match/MatchParticipant.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create matchup DTOs</name>
  <files>
    Transcendence.Service.Core/Services/Analytics/Models/MatchupDto.cs
  </files>
  <action>
    Create DTOs for matchup data:

    ```csharp
    namespace Transcendence.Service.Core.Services.Analytics.Models;

    /// <summary>
    /// Individual matchup entry against a specific opponent.
    /// </summary>
    public record MatchupEntryDto(
        int OpponentChampionId,
        int Games,                // Total games in this matchup
        int Wins,                 // Wins against this opponent
        int Losses,               // Losses against this opponent
        double WinRate            // Win rate in this matchup (0.0 to 1.0)
    );

    /// <summary>
    /// Complete matchup summary for a champion.
    /// </summary>
    public record ChampionMatchupsResponse(
        int ChampionId,
        string Role,
        string RankTier,
        string Patch,
        List<MatchupEntryDto> Counters,         // Top 5 bad matchups (low win rate)
        List<MatchupEntryDto> FavorableMatchups // Top 5 good matchups (high win rate)
    );
    ```
  </action>
  <verify>File exists: `type Transcendence.Service.Core\Services\Analytics\Models\MatchupDto.cs`</verify>
  <done>Matchup DTOs include game count for reliability assessment per user decision</done>
</task>

<task type="auto">
  <name>Task 2: Implement matchup computation with lane-specific self-join</name>
  <files>
    Transcendence.Service.Core/Services/Analytics/Interfaces/IChampionAnalyticsComputeService.cs
    Transcendence.Service.Core/Services/Analytics/Implementations/ChampionAnalyticsComputeService.cs
  </files>
  <action>
    1. **Add to IChampionAnalyticsComputeService.cs**:
       ```csharp
       Task<ChampionMatchupsResponse> ComputeMatchupsAsync(
           int championId,
           string role,
           string? rankTier,
           string patch,
           CancellationToken ct);
       ```

    2. **Add to ChampionAnalyticsComputeService.cs**:
       ```csharp
       private const int MinMatchupSampleSize = 30;
       private const int MatchupsToShow = 5;

       public async Task<ChampionMatchupsResponse> ComputeMatchupsAsync(
           int championId,
           string role,
           string? rankTier,
           string patch,
           CancellationToken ct)
       {
           // Self-join: champion participant vs opponent in same role, different team
           // This gives us lane-specific matchups (Mid vs Mid, Top vs Top, etc.)

           var championQuery = db.MatchParticipants
               .AsNoTracking()
               .Where(mp => mp.ChampionId == championId
                         && mp.TeamPosition == role
                         && mp.Match.Patch == patch
                         && mp.Match.Status == FetchStatus.Success);

           // Apply rank tier filter if specified
           if (!string.IsNullOrEmpty(rankTier))
           {
               championQuery = championQuery
                   .Join(
                       db.Ranks.Where(r => r.Tier == rankTier && r.QueueType == "RANKED_SOLO_5x5"),
                       mp => mp.SummonerId,
                       r => r.SummonerId,
                       (mp, r) => mp
                   );
           }

           // Join with opponent: same match, same role, different team
           var matchups = await championQuery
               .Join(
                   db.MatchParticipants,
                   champion => champion.MatchId,
                   opponent => opponent.MatchId,
                   (champion, opponent) => new { Champion = champion, Opponent = opponent }
               )
               .Where(x => x.Champion.TeamPosition == x.Opponent.TeamPosition  // Same role (lane matchup)
                        && x.Champion.TeamId != x.Opponent.TeamId)              // Different team (opponent)
               .GroupBy(x => x.Opponent.ChampionId)
               .Select(g => new MatchupEntryDto(
                   g.Key,
                   g.Count(),
                   g.Sum(x => x.Champion.Win ? 1 : 0),
                   g.Sum(x => x.Champion.Win ? 0 : 1),
                   g.Count() > 0 ? (double)g.Sum(x => x.Champion.Win ? 1 : 0) / g.Count() : 0.0
               ))
               .Where(m => m.Games >= MinMatchupSampleSize)
               .ToListAsync(ct);

           // Separate counters (low win rate) and favorable (high win rate)
           // Counter = opponent you lose to (< 48% win rate)
           // Favorable = opponent you beat (> 52% win rate)
           var counters = matchups
               .Where(m => m.WinRate < 0.48)
               .OrderBy(m => m.WinRate)
               .Take(MatchupsToShow)
               .ToList();

           var favorable = matchups
               .Where(m => m.WinRate > 0.52)
               .OrderByDescending(m => m.WinRate)
               .Take(MatchupsToShow)
               .ToList();

           return new ChampionMatchupsResponse(
               championId,
               role,
               rankTier ?? "all",
               patch,
               counters,
               favorable
           );
       }
       ```

    **Key implementation details:**
    - Self-join MatchParticipants on MatchId with filters: same role, different team
    - This ensures lane-specific matchups (not Top vs Bot)
    - Counter threshold: < 48% win rate (you lose more than you win)
    - Favorable threshold: > 52% win rate (you win more than you lose)
    - Minimum 30 games per matchup (lower than 100-game champion minimum because matchup combinations are sparser)
    - Show top 5 each per user decision from RESEARCH.md
  </action>
  <verify>Build: `dotnet build Transcendence.Service.Core`</verify>
  <done>Matchup computation uses lane-specific self-join with 30-game minimum per matchup</done>
</task>

<task type="auto">
  <name>Task 3: Add matchups caching and controller endpoint</name>
  <files>
    Transcendence.Service.Core/Services/Analytics/Interfaces/IChampionAnalyticsService.cs
    Transcendence.Service.Core/Services/Analytics/Implementations/ChampionAnalyticsService.cs
    Transcendence.WebAPI/Controllers/ChampionAnalyticsController.cs
  </files>
  <action>
    1. **Add to IChampionAnalyticsService.cs**:
       ```csharp
       Task<ChampionMatchupsResponse> GetMatchupsAsync(
           int championId,
           string role,
           string? rankTier,
           CancellationToken ct);
       ```

    2. **Add to ChampionAnalyticsService.cs**:
       ```csharp
       private const string MatchupsCacheKeyPrefix = "analytics:matchups:";

       public async Task<ChampionMatchupsResponse> GetMatchupsAsync(
           int championId,
           string role,
           string? rankTier,
           CancellationToken ct)
       {
           var patch = await GetCurrentPatchAsync(ct);
           var normalizedRole = role.ToUpperInvariant();
           var normalizedTier = rankTier ?? "all";
           var cacheKey = $"{MatchupsCacheKeyPrefix}{championId}:{normalizedRole}:{normalizedTier}:{patch}";
           var tags = new[] { "analytics", $"patch:{patch}", "matchups" };

           return await cache.GetOrCreateAsync(
               cacheKey,
               async cancel => await computeService.ComputeMatchupsAsync(
                   championId, normalizedRole, rankTier, patch, cancel),
               AnalyticsCacheOptions,
               tags,
               cancellationToken: ct);
       }
       ```

    3. **Add to ChampionAnalyticsController.cs**:
       ```csharp
       /// <summary>
       /// Get matchup data (counters and favorable matchups) for a champion in a role.
       /// Matchups are lane-specific (e.g., Mid vs Mid).
       /// </summary>
       /// <param name="championId">Champion ID</param>
       /// <param name="role">Role: TOP, JUNGLE, MIDDLE, BOTTOM, UTILITY</param>
       /// <param name="rankTier">Optional: Filter by rank tier</param>
       [HttpGet("champions/{championId}/matchups")]
       public async Task<ActionResult<ChampionMatchupsResponse>> GetMatchups(
           int championId,
           [FromQuery] string role,
           [FromQuery] string? rankTier = null,
           CancellationToken ct = default)
       {
           if (string.IsNullOrEmpty(role))
               return BadRequest("Role parameter is required");

           var result = await analyticsService.GetMatchupsAsync(championId, role, rankTier, ct);
           return Ok(result);
       }
       ```
  </action>
  <verify>
    Build: `dotnet build Transcendence.sln`
  </verify>
  <done>Matchups endpoint returns top 5 counters and top 5 favorable matchups with game counts</done>
</task>

</tasks>

<verification>
1. `dotnet build Transcendence.sln` succeeds
2. MatchupEntryDto contains OpponentChampionId, Games, Wins, Losses, WinRate
3. Self-join filters: same role (lane-specific), different team (opponent)
4. Counter threshold: < 48% win rate
5. Favorable threshold: > 52% win rate
6. Minimum 30 games per individual matchup
7. Top 5 counters + top 5 favorable returned
8. Game count displayed for reliability assessment
</verification>

<success_criteria>
- Matchups are lane-specific (Mid vs Mid, Top vs Top, not Mid vs Top)
- Top 5 counters (champions that beat you) with win rate < 48%
- Top 5 favorable matchups (champions you beat) with win rate > 52%
- Each matchup shows game count for users to assess reliability
- Minimum 30 games per matchup to filter out noise
- Results cached for 24 hours
</success_criteria>

<output>
After completion, create `.planning/phases/03-champion-analytics/03-04-SUMMARY.md`
</output>
